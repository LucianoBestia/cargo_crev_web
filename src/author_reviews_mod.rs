//! author_reviews_mod

//use crate::proof_mod::*;
//use crate::proof_index_mod::*;
//use crate::data_file_scan_mod::*;

/*
pub fn prepare_proofs_for_author() -> Vec<Proof> {
    //fill ProofIndex
    let proof_index = ProofIndex::new();

// pub fn new() -> ProofIndex {

    //get_review_pk


    // file scan for proofs
    //fn get_vector_of_proof_by_review_pk(path_name: &str, review_pks: Vec<ReviewPk>) -> Vec<Proof> {

}

// from the index returns path_name and ReviewPk
pub fn get_review_pk_for_author(proof_index: &ProofIndex, author_url: &str) -> Vec<OneFileReviewsPk> {
    // if they are sorted by author_url, than is easy
    let vec_one_file_reviews_pk = vec![];
    let old_file_path = "";
    let ret = vec![];
    let myp;
    for x in proof_index {
        if x.author_url == author_url {
            if x.file_path != old_file_path {
                //create new item and empty vector
                myp = vec_one_file_reviews_pk {
                    file_path: x.file_path,
                    reviews_pk: vec![],
                };
            }
            // push to vector
            myp.reviews_pk.push(ReviewPk {
                crate_name: x.crate_name,
                author_url: x.author_url,
                version: x.version,
            });
        }
    }
}
*/
